= Erstellen von neuen Plugins

Hier wird das Erstellen von neuen Plugins für Masken der WFC Anwendung dokumentiert. Alle Funktionen, die nicht zu der Core-Anwendung gehören, werden in Plugins ausgelagert. 
Mit der Version 12 wird in Masken kein JavaScript mehr ausgewertet. Die entsprechenden Funktionen müssen ebenfalls in einen Helper ausgelagert werden.

Prinzipiell wird für jede Maske ein eigenes Repository und Plugin erstellt.

Grob müssen folgende Schritte befolgt werden:

1. Erstellen des Projekts
2. Erstellen des Plugins
3. Erstellen der Klasse
4. Umsetzen der Funktionalitäten
5. Bauen des Plugins
6. Ausliefern/Hochladen aufs CAS

Diese Schritte sind im Folgenden genauer beschrieben.

== Erstellen des Projekts

In dem Repository für die Erweiterung muss es einen Ordner `client` geben. In diesem werden die Resourcen für die WFC-Anwendung abgelegt.
Neben den eigentlichen Plugins müssen noch folgende Dateien erstellt werden:

* `.mvn/extensions.xml`
* `minova.target`
* `pom.xml`

Die `.mvn/extensions.xml` Dateil sollte folgenden Inhalt haben:

[source,xml]
----
<extensions>
  <extension>
    <groupId>org.eclipse.tycho.extras</groupId>
    <artifactId>tycho-pomless</artifactId>
    <version>2.4.0</version>
  </extension>
</extensions>
----

Damit braucht nicht jeder Unterordner eine eigene `pom.xml` um mit Maven gebaut werden zu können.

`minova.target` ist die Targetplatform für das Plugin. Um auf Klassen der Core-WFC-Anwendung zugreifen zu können ist folgender Eintrag wichtig:

[source,xml]
----
<location includeAllPlatforms="false" includeConfigurePhase="true" includeMode="planner" includeSource="true" type="InstallableUnit">
	<repository location="https://minova-afis.github.io/aero.minova.rcp.updatesite/"/>
	<unit id="aero.minova.libs.feature.feature.group" version="12.0.24.202108251158"/>
	<unit id="aero.minova.rcp.feature.feature.group" version="12.0.24.202108251158"/>
</location>
----

Die komplette Target-Platform des Workingtime-Plugins findet sich link:https://github.com/minova-afis/aero.minova.workingtime/blob/main/client/minova.target[hier].

In der `pom.xml` müssen alle Module vermerkt sein, die gebaut werden sollen. Komplette Datei für Workingtime link:https://github.com/minova-afis/aero.minova.workingtime/blob/main/client/pom.xml[hier].

[source,xml]
----
<modules>
	<module>aero.minova.workingtime.helper</module>
	<module>aero.minova.workingtime.helper.tests</module>
</modules>
----

Beispiel für ein baubares Plugin-Repository:

image:images/projectExample.png[]

Prinzipiell soll es ein eigenes Repositorie für jede Erweiterungen geben (siehe auch link:https://github.com/minova-afis/aero.minova.rcp/issues/749[#749]).
In diesem sind dann neben den Plugins für die WFC-Anwendung auch die Masken, OPs, Übersetzungen, Prozeduren, ... enthalten. Als Beispiel kann man link:https://github.com/minova-afis/aero.minova.workingtime[aero.minova.workingtime] anschauen.

== Erstellen des Plugins

In dem Repository wird ein neues Plug-In Project erstellt.

image::images/pluginErstellen.png[,300,]

Das Namesschema ist `aero.minova.<Klassenname>.helper`.

image:images/pluginDialog1.png[,300,]
image:images/pluginDialog2.png[,300,]


TODO: Plugin für Tests + automatisches Ausführen dieser beim Bauen


== Erstellen der Klasse

Damit eine Helperklasse geladen werden kann, muss dies in der zugehörigen Maske vermerkt sein:

[source,xml]
----
<form icon="JobDefinition" title="@tJobDefinition.Administration" 
  helper-class="aero.minova.jobdefinition.helper.JobDefinitionHelper" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="../../../../../../ch.minova.install/src/ch/minova/install/xsd/XMLForm.xsd">
  ....
</form>
----

Die Helperklassen müssen die Klasse ``IHelper`` implementieren. Dafür muss das Package ``aero.minova.rcp.model`` zu den benötigten Plug-Ins hinzugefügt werden.

[source,java]
----
package aero.minova.jobdefinition.helper;

import aero.minova.rcp.model.form.MDetail;
import aero.minova.rcp.model.helper.ActionCode;
import aero.minova.rcp.model.helper.IHelper;

public class JobDefinitionHelper implements IHelper {

	@Override
	public void setControls(MDetail mDetail) {
		// TODO Auto-generated method stub
	}

	@Override
	public void handleDetailAction(ActionCode code) {
		// TODO Auto-generated method stub
	}
}
----

In der ``setControls`` Methode wird das MDetail übergeben, dass unter anderem alle Felder und Grids enthält. Dieses sollte als lokale Variable gespeichert werden.

Die ``handleDetailAction`` Methode wird aufgerufen, wenn von dem/der Nutzer:in eine Aktion ausgefürt wird. Diese sind im nächsten Abschnitt erklärt.


== Umsetzen von Funktionalitäten

Alle Helper liegen im Kontext, es ist also möglich Injection zu nutzen.

Über das MDetail kann auf die Felder und Grids zugegriffen werden. Dies funktioniert jeweils über den Feldnamen (Achtung bei OPs, evtl heißen die Felder hier ``<opTitel>.<Feldname>``):

[source,java]
----
MField startDate = mDetail.getField("StartDate");
----

=== Reagieren auf Detail-Aktionen

Beim Betätigen einer Aktion im Detail wird automatisch die Methode ``handleDetailAction`` aufgerufen. Mögliche Aktionen sind:

* DEL: Löschen eines Eintrages
* NEW: Neuer Eintrag
* SAVE: Speichern/Updaten eines Eintrages, nachdem die Anfrage erfolgreich funktioniert hat
* BEFORESAVE: Speichern/Updaten, bevor die Anfrage verschickt wird
* REVERT: Zurücksetzten des Eintrages

Hier können dann z.B. Werte vorbelegt werden.

=== Belegen von Werten

Einzelne Felder können aus dem ``MDetail`` geholt und über die ``setValue`` Methode mit Werten belegt werden. Dabei ist darauf zu achten, dass als Wert ein ``Value``-Objekt zu verwenden ist, und der Datentyp zu dem Feld passen muss. Das ist besonders wichtig für ``Lookup``-Values. Als Nutzer wird ``false`` angegeben.

[source,java]
----
// Feld "startDate" mit aktuellem Datum belegen
MField startDate = mDetail.getField("StartDate");
startDate.setValue(new Value(DateUtil.getDate("0")), false);

// Versuchen, das Feld employee mit dem Lookup-Value für "janiak" vorzubelegen
MLookupField employee = (MLookupField) mDetail.getField("EmployeeKey");
LookupValueAccessor va = (LookupValueAccessor) employee.getValueAccessor();
CompletableFuture<List<LookupValue>> valueFromAsync = va.getValueFromAsync(null, "janiak");
valueFromAsync.thenAccept(l -> Display.getDefault().asyncExec(() -> {
  if (!l.isEmpty()) {
    LookupValue employeeValue = l.get(0);
    employee.setValue(employeeValue, false);
  }
}));
----

==== Dirty-Flag

Damit das Dirty-Flag richtig funktioniert müssen die vorbelegten Werte ans WFCDetailCASRequestsUtil geliefert werden. Dies funktioniert in Form einer Tabelle:

[source,java]
----
// Vorbelegte Werte werden für das DirtyFlag ans WFCDetailCASRequestUtil geliefert
Table table = new Table();
table.setName("WorkingTime");
Row r = new Row();

employee.setValue(employeeValue, false);
table.addColumn(new Column(employee.getName(), employee.getDataType()));
r.addValue(employeeValue);

bookingDate.setValue(new Value(DateUtil.getDate("0")), false);
table.addColumn(new Column(bookingDate.getName(), bookingDate.getDataType()));
r.addValue(bookingDateValue);

t.addRow(r);
WFCDetailCASRequestsUtil casUtil = (WFCDetailCASRequestsUtil) mPerspective.getContext().get("WFCDetailCASRequestsUtil");
casUtil.setSelectedTable(t);
----


=== Reagieren auf Wert-Änderungen 

Um auf Wertänderungen reagieren zu können muss eine Klasse den ``ValueChangeListener`` bzw. den ``GridChangeListener`` implementieren.
Diese Klasse kann dann als Listener zu einem Feld oder Grid hinzugefügt werden um auf Wertänderungen zu reagieren.

[source,java]
----

TicketHelper ticketHelper = new TicketHelper(this);
mDetail.getField("OrderReceiverKey").addValueChangeListener(ticketHelper);

public class TicketHelper implements ValueChangeListener {
	@Override
	public void valueChange(ValueChangeEvent evt) {
		MLookupField lookupField = (MLookupField) evt.getField();
		String writtenText = lookupField.getWrittenText();
		if (writtenText != null && writtenText.startsWith("#")) {
				System.out.println("Eingegbenes Ticket: " + writtenText);
		}
	}
}
----



=== TODO, muss noch implementiert und dokumentiert werden

* Felder ein-/ausblenden -> Wie werden Werte ans CAS geschickt? Werden ausgeblendete Felder komplett ignoriert?
* Ganze Sections ein-/ausblenden
* Buttons aktivieren/deaktivieren
* Anwendungsspezifische Einstellungen
* Umwandeln von JavaScript zu Code im Helper

== Bauen des Plugins

Das Plugin kann gebaut werden, indem der `mvn clean verify` Befehl in dem `client` Ordner des entsprechenden Repositories ausgeführt wird. Das gebaute .jar File liegt dann im `target`-Ordner des jeweiligen Plugins.

image:images/jarExample.png[]

Alternativ kann auch ein Github-Workflow angelegt werden, der zusätzlich zum Bauen einen Tag und Release erstellt. Beispiel für Workingtime link:https://github.com/minova-afis/aero.minova.workingtime/blob/main/.github/workflows/tagAndRelease.yml[hier].

Dieser kann dann über ``Actions -> Tag and Release Workingtime - PlugIn`` automatisch ausgeführt werden.

image::images/automaticRelease.png[]

Das .jar File ist dann im Release als Asset verfügbar.


== Ausliefern/Hochladen aufs CAS

Das gebaute .jar muss vom CAS zur Verfügung gestellt werden.

Zuerst verbindet man sich mit dem System, auf welchem der CAS läuft.
Dort sucht man das Verzeichnis Minova bzw. Minova Systems und wählt in diesem das gewünschte Projekt aus.
Von dort aus navigiert man zu Shared Data\Program Files\SIS\plugins.
Im Plugins Ordner legt man dann einfach die .jar ab.
Zum Schluss muss nur noch das CAS neu gestartet werden, damit ein neues ZIP erzeugt wird, in welchem das neue Plugin vorhanden ist.
